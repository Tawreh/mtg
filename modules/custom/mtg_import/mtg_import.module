<?php

/**
 * @file
 * Module file for the mtg_import module.
 *
 * Includes helper functions and Drupal hooks.
 */

use Drupal\node\Entity\Node;
use Drupal\file\Entity\File;
use Drupal\taxonomy\Entity\Term;
use Drupal\taxonomy\Entity\Vocabulary;
use Drupal\taxonomy\TermStorage;

/**
 * Parse set and block data from a JSON file. Add new terms if none exist. Throw
 * an exception if there is no set information in the JSON file.
 *
 * @see callback_batch_operation
 *
 * @param array $context
 *   The batch context array, passed by reference.
 */
function mtg_import_parse_set_data($json_data, &$context) {
  $error = FALSE;
  $message = '';

  if (isset($json_data->block)) {
    // Create block data, if it doesn't already exist.
    $block_data = _mtg_import_retrieve_vocabulary_tree('mtg_block', TRUE);

    if (array_key_exists($json_data->block, $block_data)) {
      $card_block = $block_data[$json_data->block];
    }
    else {
      // Create new block term.
      $card_block = _mtg_import_create_term($json_data->block, 'mtg_block');
    }

    // Store the block so it can be added to cards.
    $context['results']['block'] = $card_block;
  }

  // Each import must have a set code.
  if (isset($json_data->code) && isset($json_data->name)) {
    // Create set data, if it doesn't already exist.
    $set_data = _mtg_import_retrieve_vocabulary_tree('mtg_set', TRUE);

    if (array_key_exists($json_data->name, $set_data)) {
      $card_set = $set_data[$json_data->name];
    }
    else {
      // Create new set term.
      $extra_fields = [];
      $extra_fields['field_set_code'] = $json_data->code;

      // If there's a block for this set, add it as a term reference.
      if (isset($context['results']['block'])) {
        $extra_fields['field_block'] = $context['results']['block'];
      }

      $card_set = _mtg_import_create_term($json_data->name, 'mtg_set', $extra_fields);
    }

    // Store the set so it can be added to cards.
    $context['results']['set'] = $card_set;
  }
  else {
    $error = TRUE;
    $message = t('Unable to continue processing as there is no set information.');
  }

  // Add an error the results array, if there was one.
  if ($error) {
    $context['message'] = $message;
    $context['results']['error_message'] = $message;
    throw new Exception($message);
  }

  $context['finished'] = 1;
}

/**
 * Parse card data from a JSON file.
 * @see callback_batch_operation
 *
 * @param array $cards
 *   An array of card objects, that must include the following properties, which
 *   will be mapped to the given fields in the 'Card' entity:
 *    [name] => title
 *    [colors] => field_colours
 *    [type] => field_type
 *    [types] => field_types
 *    [subtypes] => field_subtypes
 *    [cmc] => field_converted_mana
 *    [rarity] => field_rarity
 *    [power] => field_power
 *    [toughness] => field_toughness
 *    [manaCost] => field_mana_cost
 *    [text] => field_text
 *    [number] => field_number
 *    [watermark] => field_affiliation
 *    [imageName] => field_image_name
 * @param int $count
 *   The number of chunks total.
 * @param array $context
 *   The batch context array, passed by reference.
 */
function mtg_import_parse_card_data($cards, &$context) {
  if (!isset($context['sandbox']['progress'])) {
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['max_chunks'] = 3;
  }

  if (!isset($context['results']['tally'])) {
    $context['results']['tally'] = [
      'success' => 0,
      'fail' => 0,
    ];
  }

  if (empty($cards)) {
    $context['finished'] = 1;
    return;
  }

  $success = $fail = 0;

  // Set up the various vocabularies for term referencing.
  $vocabularies = [
    'affiliation' => [],
    'block' => [],
    'colour' => [],
    'rarity' => [],
    'set' => [],
    'subtypes' => [],
    'types' => [],
  ];

  foreach ($vocabularies as $name => $values) {
    $vocab_values = _mtg_import_retrieve_vocabulary_tree('mtg_' . $name);

    foreach ($vocab_values as $tid => $term_data) {
      $vocabularies[$name][$term_data->name] = $term_data->tid;
    }
  }

  foreach ($cards as $card_object) {
    // Affiliation.
    if (isset($card_object->watermark)) {
      if (array_key_exists($card_object->watermark, $vocabularies['affiliation'])) {
        $affiliation = $vocabularies['affiliation'][$card_object->watermark];
      }
      else {
        // Create new affiliation term.
        $affiliation = _mtg_import_create_term($card_object->watermark, 'mtg_affiliation');

        // Also add it to the vocabularies array.
        $vocabularies['affiliation'][$card_object->watermark] = $affiliation;
      }
    }
    else {
      $affiliation = NULL;
    }

    // Colours. If empty, mark as colourless.
    $colours = [];
    if (isset($card_object->colors)) {
      foreach ($card_object->colors as $colour_name) {
        $colours[] = $vocabularies['colour'][$colour_name];
      }
    }

    if (empty($colours)) {
      $colours[] = $vocabularies['colour']['Colourless'];
    }

    // Rarity.
    if (isset($card_object->rarity)) {
      if (array_key_exists($card_object->rarity, $vocabularies['rarity'])) {
        $rarity = $vocabularies['rarity'][$card_object->rarity];
      }
      else {
        // Create new rarity term.
        $rarity = _mtg_import_create_term($card_object->rarity, 'mtg_rarity');

        // Also add it to the vocabularies array.
        $vocabularies['rarity'][$card_object->rarity] = $rarity;
      }
    }
    else {
      $rarity = NULL;
    }

    // Subtypes.
    $subtypes = array();
    if (isset($card_object->subtypes)) {
      foreach ($card_object->subtypes as $subtype) {
        if (array_key_exists($subtype, $vocabularies['subtypes'])) {
          $subtypes[] = $vocabularies['subtypes'][$subtype];
        }
        else {
          // Create new subtypes term.
          $subtype = _mtg_import_create_term($subtype, 'mtg_subtypes');

          $subtypes[] = $subtype;

          // Also add it to the vocabularies array.
          $vocabularies['subtypes'][$subtype] = $subtype;
        }
      }
    }

    // Types.
    $types = array();
    if (isset($card_object->types)) {
      foreach ($card_object->types as $type) {
        if (array_key_exists($type, $vocabularies['types'])) {
          $types[] = $vocabularies['types'][$type];
        }
        else {
          // Create new types term.
          $new_type = _mtg_import_create_term($type, 'mtg_types');
          $types[] = $new_type;

          // Also add it to the vocabularies array.
          $vocabularies['types'][$type] = $new_type;
        }
      }
    }

    // Create a new card.
    try {
      $card = Node::create([
        'type' => 'card',
        'title' => $card_object->name,
        'uuid' => $card_object->multiverseid,
        'field_card_id' => $card_object->multiverseid,
        'field_number' => $card_object->number,
        'field_block' => $context['results']['block'],
        'field_set' => $context['results']['set'],
        'field_affiliation' => $affiliation,
        'field_colours' => $colours,
        'field_rarity' => $rarity,
        'field_type' => isset($card_object->type) ? $card_object->type : '',
        'field_types' => $types,
        'field_subtypes' => $subtypes,
        'field_cmc' => isset($card_object->cmc) ? $card_object->cmc : NULL,
        'field_power' => isset($card_object->power) ? $card_object->power : NULL,
        'field_toughness' => isset($card_object->toughness) ? $card_object->toughness : NULL,
        'field_mana_cost' => isset($card_object->manaCost) ? $card_object->manaCost : NULL,
        'field_text' => isset($card_object->text) ? $card_object->text : '',
        'field_flavour_text' => isset($card_object->flavor) ? $card_object->flavor : '',
        'field_loyalty' => isset($card_object->loyalty) ? $card_object->loyalty : NULL,
        'field_image_name' => isset($card_object->imageName) ? $card_object->imageName : NULL,
      ])->save();

      $success++;
    }
    catch (Exception $e) {
      $fail++;
      \Drupal::logger('mtg_import')->error(t('Card ID @id failed to save: ' . $e->getMessage(), ['@id' => $card_object->multiverseid]));
    }
  }

  $context['results']['tally']['success'] += $success;
  $context['results']['tally']['fail'] += $fail;
  $context['finished'] = 1;
}

/**
 * Finished batch.
 */
function mtg_import_completed($success, $results, $operations) {
  if ($success) {
    if ($results['tally']['success']) {
      $message = \Drupal::translation()->formatPlural($results['tally']['success'], 'One card successfully imported.', '@count cards successfully imported.');
      drupal_set_message($message);
    }
    if ($results['tally']['fail']) {
      $message = \Drupal::translation()->formatPlural($results['tally']['fail'], 'One card failed to import. See the error log for information.', '@count cards failed to import. See the error log for information.');
      drupal_set_message($message, 'error');
    }

  }
  else {
    // An error occurred.
    // $operations contains the operations that remained unprocessed.
    if (isset($results['error_message'])) {
      $message = $results['error_message'];
    }
    else {
      $error_operation = reset($operations);
      $message = t('An error occurred while processing %error_operation.', array('%error_operation' => $error_operation[0]));
    }

    drupal_set_message($message, 'error');
  }
}

/**
 * Retrieve taxonomy terms for a given vocabulary.
 *
 * @param string $vocabulary
 *   The vocabulary ID to search for.
 * @param bool $flatten
 *   Walk through the results and flatten them into term name => term ID format.
 *
 * @return array
 *   Array of taxonomy terms.
 */
function _mtg_import_retrieve_vocabulary_tree($vocabulary, $flatten = FALSE) {
  $loaded_vocabulary = \Drupal::entityManager()->getStorage('taxonomy_term')->loadTree($vocabulary);

  if ($flatten) {
    $result = [];

    foreach ($loaded_vocabulary as $term_data) {
      $result[$term_data->name] = $term_data->tid;
    }

    return $result;
  }

  return $loaded_vocabulary;
}

/**
 * Create a new taxonomy term. Return the ID of the new term.
 *
 * @param string $term
 *   Taxonomy term name.
 * @param string $vocabulary
 *   Vocabulary ID.
 * @param array $fields
 *   Optional extra fields, keyed by field_name => value.
 *
 * @return int
 *   The ID of the new term.
 */
function _mtg_import_create_term($term, $vocabulary, $fields = []) {
  $new_term = Term::create([
    'name' => $term,
    'vid' => $vocabulary,
  ]);

  if (!empty($fields)) {
    foreach ($fields as $field_name => $field_value) {
      $new_term->$field_name = $field_value;
    }
  }

  try {
    $new_term->save();
  }
  catch (Exception $e) {
    \Drupal::logger('mtg_import')->error(t('Failed to create a new term, @term, in @vocabulary. This was the error: ' . $e->getMessage(), ['@term' => $term, '@vocabulary' => $vocabulary]));
  }

  return $new_term->id();
}
