<?php

/**
 * @file
 * Module file for the mtg_import module.
 *
 * Includes helper functions and Drupal hooks.
 */

use Drupal\node\Entity\Node;
use Drupal\file\Entity\File;
use Drupal\taxonomy\Entity\Term;
use Drupal\taxonomy\Entity\Vocabulary;
use Drupal\taxonomy\TermStorage;

/**
 * Receive the JSON file ready to pass it to the importer.
 *
 * @param int $fid
 *   The ID of the JSON file.
 */
function mtg_import_receive_file($fid) {
  if ($fid == 0) {
    return FALSE;
  }

  $file = File::load($fid);

  if (!$file) {
    drupal_set_message('Unable to load file.');
    return FALSE;
  }

  $uri = $file->uri->value;
  $file_contents_raw = file_get_contents($uri);
  $file_contents = json_decode($file_contents_raw);

  // Each file should contain information about the block and the cards in it.
  // Separate the cards, then parse each part separately.
  if (isset($file_contents->cards)) {
    $cards = $file_contents->cards;
    unset($file_contents->cards);

    $cards_processed = mtg_import_parse_cards($cards);
  }

  return TRUE;

}

/**
 * Parse card data from a JSON file.
 *
 * @param array $cards
 *   An array of card objects, that must include the following properties, which
 *   will be mapped to the given fields in the 'Card' entity:
 *    [name] => title
 *    [colors] => field_colours
 *    [type] => field_type
 *    [types] => field_types
 *    [subtypes] => field_subtypes
 *    [cmc] => field_converted_mana
 *    [rarity] => field_rarity
 *    [power] => field_power
 *    [toughness] => field_toughness
 *    [manaCost] => field_mana_cost
 *    [text] => field_text
 *    [number] => field_number
 *    [watermark] => field_affiliation
 */
function mtg_import_parse_cards(array $cards) {
  if (empty($cards)) {
    return;
  }

  $success = $fail = 0;

  // Set up the various vocabularies for term referencing.
  $vocabularies = [
    'affiliation' => [],
    'block' => [],
    'colour' => [],
    'rarity' => [],
    'set' => [],
    'subtypes' => [],
    'types' => [],
  ];

  foreach ($vocabularies as $name => $values) {
    $vocab_values = _mtg_import_retrieve_vocabulary_tree('mtg_' . $name);

    foreach ($vocab_values as $tid => $term_data) {
      $vocabularies[$name][$term_data->name] = $term_data->tid;
    }
  }

  foreach ($cards as $card_object) {
    // Affiliation.
    if (isset($card_object->watermark)) {
      if (array_key_exists($card_object->watermark, $vocabularies['affiliation'])) {
        $affiliation = $vocabularies['affiliation'][$card_object->watermark];
      }
      else {
        // Create new affiliation term.
        $new_affiliation = Term::create([
          'name' => $card_object->watermark,
          'vid' => 'mtg_affiliation',
        ]);
        $new_affiliation->save();

        $affiliation = $new_affiliation->id();

        // Also add it to the vocabularies array.
        $vocabularies['affiliation'][$card_object->watermark] = $new_affiliation->id();
      }
    }
    else {
      $affiliation = NULL;
    }

    // Colours. If empty, mark as colourless.
    $colours = [];
    if (isset($card_object->colors)) {
      foreach ($card_object->colors as $colour_name) {
        $colours[] = $vocabularies['colour'][$colour_name];
      }
    }

    if (empty($colours)) {
      $colours[] = $vocabularies['colour']['Colourless'];
    }

    // Rarity.
    if (isset($card_object->rarity)) {
      if (array_key_exists($card_object->rarity, $vocabularies['rarity'])) {
        $rarity = $vocabularies['rarity'][$card_object->rarity];
      }
      else {
        // Create new rarity term.
        $new_rarity = Term::create([
          'name' => $card_object->rarity,
          'vid' => 'mtg_rarity',
        ]);
        $new_rarity->save();

        $rarity = $new_rarity->id();

        // Also add it to the vocabularies array.
        $vocabularies['rarity'][$card_object->rarity] = $new_rarity->id();
      }
    }
    else {
      $rarity = NULL;
    }

    // Subtypes.
    $subtypes = array();
    if (isset($card_object->subtypes)) {
      foreach ($card_object->subtypes as $subtype) {
        if (array_key_exists($subtype, $vocabularies['subtypes'])) {
          $subtypes[] = $vocabularies['subtypes'][$subtype];
        }
        else {
          // Create new subtypes term.
          $new_subtype = Term::create([
            'name' => $subtype,
            'vid' => 'mtg_subtypes',
          ]);
          $new_subtype->save();

          $subtypes[] = $new_subtype->id();

          // Also add it to the vocabularies array.
          $vocabularies['subtypes'][$subtype] = $new_subtype->id();
        }
      }
    }

    // Types.
    $types = array();
    if (isset($card_object->types)) {
      foreach ($card_object->types as $type) {
        if (array_key_exists($type, $vocabularies['types'])) {
          $types[] = $vocabularies['types'][$type];
        }
        else {
          // Create new types term.
          $new_type = Term::create([
            'name' => $type,
            'vid' => 'mtg_types',
          ]);
          $new_type->save();

          // dpm($new_type);
          $types[] = $new_type->id();

          // Also add it to the vocabularies array.
          $vocabularies['types'][$type] = $new_type->id();
        }
      }
    }

    // Create a new card.
    try {
      $card = Node::create([
        'type' => 'card',
        'title' => $card_object->name,
        'uuid' => $card_object->multiverseid,
        'field_card_id' => $card_object->multiverseid,
        'field_number' => $card_object->number,
        'field_affiliation' => $affiliation,
        'field_colours' => $colours,
        'field_rarity' => $rarity,
        'field_type' => isset($card_object->type) ? $card_object->type : '',
        'field_types' => $types,
        'field_subtypes' => $subtypes,
        'field_cmc' => isset($card_object->cmc) ? $card_object->cmc : NULL,
        'field_power' => isset($card_object->power) ? $card_object->power : NULL,
        'field_toughness' => isset($card_object->toughness) ? $card_object->toughness : NULL,
        'field_mana_cost' => isset($card_object->manaCost) ? $card_object->manaCost : NULL,
        'field_text' => isset($card_object->text) ? $card_object->text : '',
        'field_flavour_text' => isset($card_object->flavor) ? $card_object->flavor : '',
        'field_loyalty' => isset($card_object->loyalty) ? $card_object->loyalty : NULL,
      ])->save();
      $success++;
    }
    catch (Exception $e) {
      $fail++;
      \Drupal::logger('mtg_import')->error(t('Card ID @id failed to save: ' . $e->getMessage(), ['@id' => $card_object->multiverseid]));
    }
  }

  if ($success) {
    drupal_set_message(t('Successfully imported @x cards.', ['@x' => $success]));
  }
  if ($fail) {
    drupal_set_message(t('Failed to import @x cards. See the <a href="@error_log">error log</a> for details.', ['@x' => $fail, '@error_log' => '/admin/reports/dblog']), 'error');
  }
}

/**
 * Retrieve taxonomy terms for a given vocabulary.
 *
 * @param string $vocabulary
 *   The vocabulary ID to search for.
 *
 * @return array
 *   Array of taxonomy terms.
 */
function _mtg_import_retrieve_vocabulary_tree($vocabulary) {
  return \Drupal::entityManager()->getStorage('taxonomy_term')->loadTree($vocabulary);
}
